=====STUDENT TESTS=====
====Good Tests====
===[good0.bminor Input]===
str: string = "bye";
main: function void () = {
    if (1 == 1) {
        print "hello world!\n";
    }
}


===[good0.bminor Output]===
.file "htrinh-compiler/tests/codegen/good0.bminor"
.data
.global str
str:
.quad .L0
.data
.global .L0
.L0:
.string "bye"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# start of if stmt
# condition expr
# code of cmp 
# expr int
	movq $1, %rbx
# expr int
	movq $1, %r10
	cmpq %r10, %rbx
	je .L3
# if false
.L4:
	movq $0, %r10
	jmp .L5
# if true
.L3:
	movq $1, %r10
	jmp .L5
# continue
.L5:
# end of cmp 
	cmpq $0, %r10
	je .L1
# if body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L6:
	.string "hello world!\n"
.text
	leaq .L6, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
	jmp .L2
# false label
.L1:
# else body
.L2:
# end of if stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

hello world!


return code: 13


===[good1.bminor Input]===
// tests array index

arr: array [4] integer = {1,2,3,4};

main:function integer () = {
     
    print arr[0]," ", arr[1], " ", arr[2], " ", arr[3], "\n";

    print "yes\n";
    
    return 0;	
}

===[good1.bminor Output]===
.file "htrinh-compiler/tests/codegen/good1.bminor"
.data
.global arr
arr:
	.quad 1
	.quad 2
	.quad 3
	.quad 4
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# code of index array
# expr int
	movq $0, %r10
	leaq arr, %rbx
	movq %r10, %rax
	movq $8, %r11
	imulq %r11
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string " "
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of index array
# expr int
	movq $1, %r11
	leaq arr, %rbx
	movq %r11, %rax
	movq $8, %r12
	imulq %r12
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string " "
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of index array
# expr int
	movq $2, %r12
	leaq arr, %rbx
	movq %r12, %rax
	movq $8, %r13
	imulq %r13
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string " "
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of index array
# expr int
	movq $3, %r13
	leaq arr, %rbx
	movq %r13, %rax
	movq $8, %r14
	imulq %r14
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L3:
	.string "\n"
.text
	leaq .L3, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L4:
	.string "yes\n"
.text
	leaq .L4, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

1 2 3 4
yes


return code: 0


===[good10.bminor Input]===
// test ++ and -- 


main:function integer ()= {
    x: integer = 0;
    y:integer = 1;
    
    a: integer = x++;
    print "a should be 0, x should be 1: ", "a = ", a, " x = ", x, "\n";

    a = y--;
    print "a should be 1, y should be 0: ", "a = ", a, " y = ", y, "\n";	

}


===[good10.bminor Output]===
.file "htrinh-compiler/tests/codegen/good10.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $24, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl x
# expr int
	movq $0, %rbx
# code for decl x
	movq %rbx, -8(%rbp)
# code for value of decl y
# expr int
	movq $1, %rbx
# code for decl y
	movq %rbx, -16(%rbp)
# code for value of decl a
# code of ++
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %r10
	incq %rbx
	movq %rbx, -8(%rbp)
# end of ++
# code for decl a
	movq %r10, -24(%rbp)
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "a should be 0, x should be 1: "
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string "a = "
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq -24(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string " x = "
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L3:
	.string "\n"
.text
	leaq .L3, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# code of --
# expr id
	movq -16(%rbp), %rbx
	movq %rbx, %r10
	decq %rbx
	movq %rbx, -16(%rbp)
# end of --
	leaq -24(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L4:
	.string "a should be 1, y should be 0: "
.text
	leaq .L4, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L5:
	.string "a = "
.text
	leaq .L5, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq -24(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L6:
	.string " y = "
.text
	leaq .L6, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq -16(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L7:
	.string "\n"
.text
	leaq .L7, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

a should be 0, x should be 1: a = 0 x = 1
a should be 1, y should be 0: a = 1 y = 0


return code: 1


===[good11.bminor Input]===
// negate

main:function integer ()= {
    x: integer = 0;
    a: integer = x++;
    a = -a;
    print "a should be -1, x should be 1: ", "a = ", a, " x = ", x, "\n";
}


===[good11.bminor Output]===
.file "htrinh-compiler/tests/codegen/good11.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $16, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl x
# expr int
	movq $0, %rbx
# code for decl x
	movq %rbx, -8(%rbp)
# code for value of decl a
# code of ++
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %r10
	incq %rbx
	movq %rbx, -8(%rbp)
# end of ++
# code for decl a
	movq %r10, -16(%rbp)
# code of id =
# code of negate
# expr id
	movq -16(%rbp), %rbx
	negq %rbx
# end of negate
	leaq -16(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "a should be -1, x should be 1: "
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string "a = "
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq -16(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string " x = "
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L3:
	.string "\n"
.text
	leaq .L3, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

a should be -1, x should be 1: a = 0 x = 1


return code: 1


===[good12.bminor Input]===
// for loop

main:function integer () = {
	
    i: integer = 0;

    for (i = 0; i < 4; i++) {
        print i;
    }
    
    print "\n";
    i = 0;
    for (; i < 4; i++) {
        print i;
    }
    print "\n";

    for (i=0; i < 4; ) {
        print i;
        i = i+1;
    }
    print "\n";
    
}

===[good12.bminor Output]===
.file "htrinh-compiler/tests/codegen/good12.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl i
# expr int
	movq $0, %rbx
# code for decl i
	movq %rbx, -8(%rbp)
# start of for loop
# init expr
# code of id =
# expr int
	movq $0, %rbx
	leaq -8(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
.L0:
# condition expr
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $4, %r10
	cmpq %r10, %rbx
	jl .L2
# if false
.L3:
	movq $0, %r10
	jmp .L4
# if true
.L2:
	movq $1, %r10
	jmp .L4
# continue
.L4:
# end of cmp 
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $4, %r11
	cmpq %r11, %rbx
	jl .L5
# if false
.L6:
	movq $0, %r11
	jmp .L7
# if true
.L5:
	movq $1, %r11
	jmp .L7
# continue
.L7:
# end of cmp 
	cmpq $0, %r11
	je .L1
# loop body
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# next expr
# code of ++
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %r11
	incq %rbx
	movq %rbx, -8(%rbp)
# end of ++
	jmp .L0
.L1:
# end of for loop
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L8:
	.string "\n"
.text
	leaq .L8, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# expr int
	movq $0, %rbx
	leaq -8(%rbp), %r11
	movq %rbx, (%r11)
# end of id =
# start of for loop
# init expr
.L9:
# condition expr
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $4, %r11
	cmpq %r11, %rbx
	jl .L11
# if false
.L12:
	movq $0, %r11
	jmp .L13
# if true
.L11:
	movq $1, %r11
	jmp .L13
# continue
.L13:
# end of cmp 
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $4, %r12
	cmpq %r12, %rbx
	jl .L14
# if false
.L15:
	movq $0, %r12
	jmp .L16
# if true
.L14:
	movq $1, %r12
	jmp .L16
# continue
.L16:
# end of cmp 
	cmpq $0, %r12
	je .L10
# loop body
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# next expr
# code of ++
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %r12
	incq %rbx
	movq %rbx, -8(%rbp)
# end of ++
	jmp .L9
.L10:
# end of for loop
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L17:
	.string "\n"
.text
	leaq .L17, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of for loop
# init expr
# code of id =
# expr int
	movq $0, %rbx
	leaq -8(%rbp), %r12
	movq %rbx, (%r12)
# end of id =
.L18:
# condition expr
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $4, %r12
	cmpq %r12, %rbx
	jl .L20
# if false
.L21:
	movq $0, %r12
	jmp .L22
# if true
.L20:
	movq $1, %r12
	jmp .L22
# continue
.L22:
# end of cmp 
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $4, %r13
	cmpq %r13, %rbx
	jl .L23
# if false
.L24:
	movq $0, %r13
	jmp .L25
# if true
.L23:
	movq $1, %r13
	jmp .L25
# continue
.L25:
# end of cmp 
	cmpq $0, %r13
	je .L19
# loop body
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# code of add
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $1, %r13
	addq %rbx, %r13
# end of add
	leaq -8(%rbp), %rbx
	movq %r13, (%rbx)
# end of id =
# next expr
	jmp .L18
.L19:
# end of for loop
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L26:
	.string "\n"
.text
	leaq .L26, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

0123
0123
0123


return code: 1


===[good13.bminor Input]===
// test and, or, not 

main:function integer () =
{
	print "true: ", true&&true, " false: ", true&&false, ", true: ", true||false, "\n";

    print "false: ", !true, ", false: ", !true, ", true: ", !!true, "\n";
}
===[good13.bminor Output]===
.file "htrinh-compiler/tests/codegen/good13.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "true: "
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of and
# expr bool
	movq $0, %rbx
# expr bool
	movq $0, %r10
	andq %rbx, %r10
# end of and
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string " false: "
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of and
# expr bool
	movq $0, %rbx
# expr bool
	movq $1, %r10
	andq %rbx, %r10
# end of and
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string ", true: "
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of or
# expr bool
	movq $0, %rbx
# expr bool
	movq $1, %r10
	orq %rbx, %r10
# end of or
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L3:
	.string "\n"
.text
	leaq .L3, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L4:
	.string "false: "
.text
	leaq .L4, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of not
# expr bool
	movq $0, %rbx
	cmpq $0, %rbx
	je .L5
	movq $0, %rbx
	jmp .L6
.L5:
	movq $1, %rbx
.L6:
# end of not
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L7:
	.string ", false: "
.text
	leaq .L7, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of not
# expr bool
	movq $0, %rbx
	cmpq $0, %rbx
	je .L8
	movq $0, %rbx
	jmp .L9
.L8:
	movq $1, %rbx
.L9:
# end of not
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L10:
	.string ", true: "
.text
	leaq .L10, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of not
# code of not
# expr bool
	movq $0, %rbx
	cmpq $0, %rbx
	je .L13
	movq $0, %rbx
	jmp .L14
.L13:
	movq $1, %rbx
.L14:
# end of not
	cmpq $0, %rbx
	je .L11
	movq $0, %rbx
	jmp .L12
.L11:
	movq $1, %rbx
.L12:
# end of not
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L15:
	.string "\n"
.text
	leaq .L15, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

true: false false: false, true: true
false: true, false: true, true: false


return code: 1


===[good14.bminor Input]===
// if-else

main:function integer () =
{
    if (true && false) {
        print "should not be printed\n";
    } else if (true || false) {
        print "should be printed\n";
    } else {
        print "should not be printed\n";
    }

    if (!true) 
        print "should not be printed\n";
    else if (!false)
        print "should be printed\n";
    else
        print "should not be printed\n";

    if (true)
        if (true) print "should be printed\n";
        else print "should not be printed\n";
    return 0;
}

===[good14.bminor Output]===
.file "htrinh-compiler/tests/codegen/good14.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# start of if stmt
# condition expr
# code of and
# expr bool
	movq $0, %rbx
# expr bool
	movq $1, %r10
	andq %rbx, %r10
# end of and
	cmpq $0, %r10
	je .L0
# if body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string "should not be printed\n"
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
	jmp .L1
# false label
.L0:
# else body
# start of if stmt
# condition expr
# code of or
# expr bool
	movq $0, %rbx
# expr bool
	movq $1, %r11
	orq %rbx, %r11
# end of or
	cmpq $0, %r11
	je .L3
# if body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L5:
	.string "should be printed\n"
.text
	leaq .L5, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
	jmp .L4
# false label
.L3:
# else body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L6:
	.string "should not be printed\n"
.text
	leaq .L6, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
.L4:
# end of if stmt
.L1:
# end of if stmt
# start of if stmt
# condition expr
# code of not
# expr bool
	movq $0, %rbx
	cmpq $0, %rbx
	je .L9
	movq $0, %rbx
	jmp .L10
.L9:
	movq $1, %rbx
.L10:
# end of not
	cmpq $0, %rbx
	je .L7
# if body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L11:
	.string "should not be printed\n"
.text
	leaq .L11, %r10
# end of expr string
	movq %r10, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
	jmp .L8
# false label
.L7:
# else body
# start of if stmt
# condition expr
# code of not
# expr bool
	movq $1, %r10
	cmpq $0, %r10
	je .L14
	movq $0, %r10
	jmp .L15
.L14:
	movq $1, %r10
.L15:
# end of not
	cmpq $0, %r10
	je .L12
# if body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L16:
	.string "should be printed\n"
.text
	leaq .L16, %r11
# end of expr string
	movq %r11, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
	jmp .L13
# false label
.L12:
# else body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L17:
	.string "should not be printed\n"
.text
	leaq .L17, %r11
# end of expr string
	movq %r11, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
.L13:
# end of if stmt
.L8:
# end of if stmt
# start of if stmt
# condition expr
# expr bool
	movq $0, %rbx
	cmpq $0, %rbx
	je .L18
# if body
# start of if stmt
# condition expr
# expr bool
	movq $0, %r10
	cmpq $0, %r10
	je .L20
# if body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L22:
	.string "should be printed\n"
.text
	leaq .L22, %r11
# end of expr string
	movq %r11, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
	jmp .L21
# false label
.L20:
# else body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L23:
	.string "should not be printed\n"
.text
	leaq .L23, %r11
# end of expr string
	movq %r11, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
.L21:
# end of if stmt
	jmp .L19
# false label
.L18:
# else body
.L19:
# end of if stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

should be printed
should not be printed


return code: 0


===[good15.bminor Input]===
// tests exponents 

x:integer = 2;
main: function integer () =
{
    print " should be 64 and 0: \n";
    print (x^6), " ", (x^-4), "\n";	
    return x;
}

===[good15.bminor Output]===
.file "htrinh-compiler/tests/codegen/good15.bminor"
.data
.global x
x:
.quad 2
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string " should be 64 and 0: \n"
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# code of exp
# expr id
	movq x, %rbx
# expr int
	movq $6, %r10
	pushq %r10
	pushq %r11
	movq %rbx, %rdi
	movq %r10, %rsi
	call integer_power
	popq %r11
	popq %r10
	movq %rax, %r10
# end of exp
	movq %r10, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string " "
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of exp
# expr id
	movq x, %rbx
# code of negate
# expr int
	movq $4, %r10
	negq %r10
# end of negate
	pushq %r10
	pushq %r11
	movq %rbx, %rdi
	movq %r10, %rsi
	call integer_power
	popq %r11
	popq %r10
	movq %rax, %r10
# end of exp
	movq %r10, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string "\n"
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr id
	movq x, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

 should be 64 and 0: 
64 1


return code: 2


===[good16.bminor Input]===
// tests auto 
x: auto = 1;
b: auto = true;
c: auto = 'a';

main: function integer () = {
	print x, b, c, "\n";
}

===[good16.bminor Output]===
.file "htrinh-compiler/tests/codegen/good16.bminor"
.data
.global x
x:
.quad 1
.data
.global b
b:
	.quad 0
.data
.global c
c:
.quad 97
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq x, %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq b, %rbx
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq c, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "\n"
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

1falsea


return code: 1


===[good17.bminor Input]===
// test while loops

main: function void () =
{
	i: integer;
	i = 0;
    while(i<10) {
        print i;
        i++;
    }
    print "\n";
}


===[good17.bminor Output]===
.file "htrinh-compiler/tests/codegen/good17.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code of id =
# expr int
	movq $0, %rbx
	leaq -8(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
# start of while loop
.L0:
# condition expr
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $10, %r10
	cmpq %r10, %rbx
	jl .L2
# if false
.L3:
	movq $0, %r10
	jmp .L4
# if true
.L2:
	movq $1, %r10
	jmp .L4
# continue
.L4:
# end of cmp 
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $10, %r11
	cmpq %r11, %rbx
	jl .L5
# if false
.L6:
	movq $0, %r11
	jmp .L7
# if true
.L5:
	movq $1, %r11
	jmp .L7
# continue
.L7:
# end of cmp 
	cmpq $0, %r11
	je .L1
# while body
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# code of ++
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %r11
	incq %rbx
	movq %rbx, -8(%rbp)
# end of ++
	jmp .L0
.L1:
# end of while loop
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L8:
	.string "\n"
.text
	leaq .L8, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

0123456789


return code: 1


===[good18.bminor Input]===
// test nested for loops


main: function void () =
{
	i: integer;
	j: integer;
	
	for(j=0;j<10;j++) {
		for(i=0;i<10;i++) {
            print i, j;
            print "\n";
		}
	}
}


===[good18.bminor Output]===
.file "htrinh-compiler/tests/codegen/good18.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $16, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# start of for loop
# init expr
# code of id =
# expr int
	movq $0, %rbx
	leaq -16(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
.L0:
# condition expr
# code of cmp 
# expr id
	movq -16(%rbp), %rbx
# expr int
	movq $10, %r10
	cmpq %r10, %rbx
	jl .L2
# if false
.L3:
	movq $0, %r10
	jmp .L4
# if true
.L2:
	movq $1, %r10
	jmp .L4
# continue
.L4:
# end of cmp 
# code of cmp 
# expr id
	movq -16(%rbp), %rbx
# expr int
	movq $10, %r11
	cmpq %r11, %rbx
	jl .L5
# if false
.L6:
	movq $0, %r11
	jmp .L7
# if true
.L5:
	movq $1, %r11
	jmp .L7
# continue
.L7:
# end of cmp 
	cmpq $0, %r11
	je .L1
# loop body
# start of for loop
# init expr
# code of id =
# expr int
	movq $0, %rbx
	leaq -8(%rbp), %r11
	movq %rbx, (%r11)
# end of id =
.L8:
# condition expr
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $10, %r11
	cmpq %r11, %rbx
	jl .L10
# if false
.L11:
	movq $0, %r11
	jmp .L12
# if true
.L10:
	movq $1, %r11
	jmp .L12
# continue
.L12:
# end of cmp 
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $10, %r12
	cmpq %r12, %rbx
	jl .L13
# if false
.L14:
	movq $0, %r12
	jmp .L15
# if true
.L13:
	movq $1, %r12
	jmp .L15
# continue
.L15:
# end of cmp 
	cmpq $0, %r12
	je .L9
# loop body
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq -16(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L16:
	.string "\n"
.text
	leaq .L16, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# next expr
# code of ++
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %r12
	incq %rbx
	movq %rbx, -8(%rbp)
# end of ++
	jmp .L8
.L9:
# end of for loop
# next expr
# code of ++
# expr id
	movq -16(%rbp), %rbx
	movq %rbx, %r12
	incq %rbx
	movq %rbx, -16(%rbp)
# end of ++
	jmp .L0
.L1:
# end of for loop
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

00
10
20
30
40
50
60
70
80
90
01
11
21
31
41
51
61
71
81
91
02
12
22
32
42
52
62
72
82
92
03
13
23
33
43
53
63
73
83
93
04
14
24
34
44
54
64
74
84
94
05
15
25
35
45
55
65
75
85
95
06
16
26
36
46
56
66
76
86
96
07
17
27
37
47
57
67
77
87
97
08
18
28
38
48
58
68
78
88
98
09
19
29
39
49
59
69
79
89
99


return code: 1


===[good19.bminor Input]===
/*
This test program prints out a maze generated
by alternating slash and backslash randomly.
It relies on the rand, srand, and time functions
found in the C standard library.
*/

rand: function integer ();
srand: function void ( seed: integer );
time: function integer ( zero: integer );

main: function void () =
{
	xsize: integer = 20;
	ysize: integer = 20;

	srand(time(0));

	i: integer;
	j: integer;
	
	for(j=0;j<ysize;j++) {
		for(i=0;i<xsize;i++) {
			if(rand()%2==1) {
				print '/';
			} else {
				print '\\';
			}
		}
		print "\n";
	}
}


===[good19.bminor Output]===
.file "htrinh-compiler/tests/codegen/good19.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $32, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl xsize
# expr int
	movq $20, %rbx
# code for decl xsize
	movq %rbx, -8(%rbp)
# code for value of decl ysize
# expr int
	movq $20, %rbx
# code for decl ysize
	movq %rbx, -16(%rbp)
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr int
	movq $0, %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call time
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# load args into arg registers
	movq %rbx, %rdi
# call function
	call srand
# restore regs after func call
	popq %r11
	popq %r10
# end of func call
# start of for loop
# init expr
# code of id =
# expr int
	movq $0, %rbx
	leaq -32(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
.L0:
# condition expr
# code of cmp 
# expr id
	movq -32(%rbp), %rbx
# expr id
	movq -16(%rbp), %r10
	cmpq %r10, %rbx
	jl .L2
# if false
.L3:
	movq $0, %r10
	jmp .L4
# if true
.L2:
	movq $1, %r10
	jmp .L4
# continue
.L4:
# end of cmp 
# code of cmp 
# expr id
	movq -32(%rbp), %rbx
# expr id
	movq -16(%rbp), %r11
	cmpq %r11, %rbx
	jl .L5
# if false
.L6:
	movq $0, %r11
	jmp .L7
# if true
.L5:
	movq $1, %r11
	jmp .L7
# continue
.L7:
# end of cmp 
	cmpq $0, %r11
	je .L1
# loop body
# start of for loop
# init expr
# code of id =
# expr int
	movq $0, %rbx
	leaq -24(%rbp), %r11
	movq %rbx, (%r11)
# end of id =
.L8:
# condition expr
# code of cmp 
# expr id
	movq -24(%rbp), %rbx
# expr id
	movq -8(%rbp), %r11
	cmpq %r11, %rbx
	jl .L10
# if false
.L11:
	movq $0, %r11
	jmp .L12
# if true
.L10:
	movq $1, %r11
	jmp .L12
# continue
.L12:
# end of cmp 
# code of cmp 
# expr id
	movq -24(%rbp), %rbx
# expr id
	movq -8(%rbp), %r12
	cmpq %r12, %rbx
	jl .L13
# if false
.L14:
	movq $0, %r12
	jmp .L15
# if true
.L13:
	movq $1, %r12
	jmp .L15
# continue
.L15:
# end of cmp 
	cmpq $0, %r12
	je .L9
# loop body
# start of if stmt
# condition expr
# code of cmp 
# code of mod
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# load args into arg registers
# call function
	call rand
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# expr int
	movq $2, %r12
	movq %rbx, %rax
	xor %rdx, %rdx
	idivq %r12
	movq %rdx, %r12
# end of mod
# expr int
	movq $1, %rbx
	cmpq %rbx, %r12
	je .L18
# if false
.L19:
	movq $0, %rbx
	jmp .L20
# if true
.L18:
	movq $1, %rbx
	jmp .L20
# continue
.L20:
# end of cmp 
	cmpq $0, %rbx
	je .L16
# if body
# print stmt
	pushq %r10
	pushq %r11
# expr char
	movq $47, %r12
	movq %r12, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
	jmp .L17
# false label
.L16:
# else body
# print stmt
	pushq %r10
	pushq %r11
# expr char
	movq $92, %r12
	movq %r12, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
.L17:
# end of if stmt
# next expr
# code of ++
# expr id
	movq -24(%rbp), %rbx
	movq %rbx, %r12
	incq %rbx
	movq %rbx, -24(%rbp)
# end of ++
	jmp .L8
.L9:
# end of for loop
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L21:
	.string "\n"
.text
	leaq .L21, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# next expr
# code of ++
# expr id
	movq -32(%rbp), %rbx
	movq %rbx, %r12
	incq %rbx
	movq %rbx, -32(%rbp)
# end of ++
	jmp .L0
.L1:
# end of for loop
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

\/\//\/\\/\\/////\//
\//\//\\\\/\///\/\\\
/\\\//////\\\/\//\\/
\///\/\//\/////\\//\
\/\\/\\\\\/\/\////\/
\\\////\\/\\\\//\//\
/\\\///\//////\/////
\/\///\/\\//\///\\\/
//\//\\\\//\\///\\\\
\//\\\\\\\\\/\/\//\/
\\/\///\//\/\\/\\/\/
/\///\/\/\//\\///\/\
/\//\//\\//\\\//\\//
\\\\\/\\//\\/\///\\/
\//\\\/\/\\/\\\\\\\/
//\///\\\\/\\/\\//\\
/\\//\//\\\//\\\\/\\
//\/\\/\/\\\\\//\\\\
\/\//\////////\//\/\
\\\\\/\/\\/\//\/\/\/


return code: 1


===[good2.bminor Input]===
// tests array index

arr: array [4] integer = {1,2,3,4};

main:function integer () = {

    arr[0] = 234;
    arr[1] = 45;
    arr[2] = 11;
    arr[3] = 12;
    
    print arr[0]," ", arr[1], " ", arr[2], " ", arr[3], "\n";
    
    return 0;	
}

===[good2.bminor Output]===
.file "htrinh-compiler/tests/codegen/good2.bminor"
.data
.global arr
arr:
	.quad 1
	.quad 2
	.quad 3
	.quad 4
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code of array =
# expr int
	movq $0, %rbx
# expr int
	movq $234, %r11
	leaq arr, %r10
	movq %rbx, %rax
	movq $8, %r12
	imulq %r12
	addq %r10, %rax
	movq %r11, (%rax)
# end of array =
# code of array =
# expr int
	movq $1, %rbx
# expr int
	movq $45, %r11
	leaq arr, %r10
	movq %rbx, %rax
	movq $8, %r12
	imulq %r12
	addq %r10, %rax
	movq %r11, (%rax)
# end of array =
# code of array =
# expr int
	movq $2, %rbx
# expr int
	movq $11, %r11
	leaq arr, %r10
	movq %rbx, %rax
	movq $8, %r12
	imulq %r12
	addq %r10, %rax
	movq %r11, (%rax)
# end of array =
# code of array =
# expr int
	movq $3, %rbx
# expr int
	movq $12, %r11
	leaq arr, %r10
	movq %rbx, %rax
	movq $8, %r12
	imulq %r12
	addq %r10, %rax
	movq %r11, (%rax)
# end of array =
# print stmt
	pushq %r10
	pushq %r11
# code of index array
# expr int
	movq $0, %r10
	leaq arr, %rbx
	movq %r10, %rax
	movq $8, %r11
	imulq %r11
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string " "
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of index array
# expr int
	movq $1, %r11
	leaq arr, %rbx
	movq %r11, %rax
	movq $8, %r12
	imulq %r12
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string " "
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of index array
# expr int
	movq $2, %r12
	leaq arr, %rbx
	movq %r12, %rax
	movq $8, %r13
	imulq %r13
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string " "
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of index array
# expr int
	movq $3, %r13
	leaq arr, %rbx
	movq %r13, %rax
	movq $8, %r14
	imulq %r14
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L3:
	.string "\n"
.text
	leaq .L3, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

234 45 11 12


return code: 0


===[good3.bminor Input]===
// test return 

main:function integer ()=
{
	return 2 * 5;
}

===[good3.bminor Output]===
.file "htrinh-compiler/tests/codegen/good3.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# code of mult
# expr int
	movq $2, %rbx
# expr int
	movq $5, %r10
	movq %r10, %rax
	imulq %rbx
	movq %rax, %r10
# end of mult
	movq %r10, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue



return code: 10


===[good4.bminor Input]===
// tests arithmetic 

main:function integer () =
{
    print 1 + 2, "\n";
    x: integer = 0;
    x = x + 1; 
    print x; 
    print " should be 1\n";
    x = x - 1; 
    print x; print " should be 0\n";
    x = 6;
    x = x * x; 
    print x; 
    print " should be 36\n";
    x = x / x; 
    print x; 
    print " should be 1\n";
    x = 2;
    print x % 2; 
    print " should be 0\n";
    print x^2; 
    print " should be 4\n";
    print x^2^3; 
    print " should be 256\n";

    return 0;	
}

===[good4.bminor Output]===
.file "htrinh-compiler/tests/codegen/good4.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# code of add
# expr int
	movq $1, %rbx
# expr int
	movq $2, %r10
	addq %rbx, %r10
# end of add
	movq %r10, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "\n"
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code for value of decl x
# expr int
	movq $0, %rbx
# code for decl x
	movq %rbx, -8(%rbp)
# code of id =
# code of add
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $1, %r10
	addq %rbx, %r10
# end of add
	leaq -8(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string " should be 1\n"
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# code of sub
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $1, %r10
	subq %rbx, %r10
# end of sub
	leaq -8(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string " should be 0\n"
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# expr int
	movq $6, %rbx
	leaq -8(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
# code of id =
# code of mult
# expr id
	movq -8(%rbp), %rbx
# expr id
	movq -8(%rbp), %r10
	movq %r10, %rax
	imulq %rbx
	movq %rax, %r10
# end of mult
	leaq -8(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L3:
	.string " should be 36\n"
.text
	leaq .L3, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# code of div
# expr id
	movq -8(%rbp), %rbx
# expr id
	movq -8(%rbp), %r10
	movq %rbx, %rax
	xor %rdx, %rdx
	idivq %r10
	movq %rax, %r10
# end of div
	leaq -8(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L4:
	.string " should be 1\n"
.text
	leaq .L4, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# expr int
	movq $2, %rbx
	leaq -8(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# code of mod
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $2, %r10
	movq %rbx, %rax
	xor %rdx, %rdx
	idivq %r10
	movq %rdx, %r10
# end of mod
	movq %r10, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L5:
	.string " should be 0\n"
.text
	leaq .L5, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# code of exp
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $2, %r10
	pushq %r10
	pushq %r11
	movq %rbx, %rdi
	movq %r10, %rsi
	call integer_power
	popq %r11
	popq %r10
	movq %rax, %r10
# end of exp
	movq %r10, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L6:
	.string " should be 4\n"
.text
	leaq .L6, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# code of exp
# expr id
	movq -8(%rbp), %rbx
# code of exp
# expr int
	movq $2, %r10
# expr int
	movq $3, %r11
	pushq %r10
	pushq %r11
	movq %r10, %rdi
	movq %r11, %rsi
	call integer_power
	popq %r11
	popq %r10
	movq %rax, %r11
# end of exp
	pushq %r10
	pushq %r11
	movq %rbx, %rdi
	movq %r11, %rsi
	call integer_power
	popq %r11
	popq %r10
	movq %rax, %r11
# end of exp
	movq %r11, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L7:
	.string " should be 256\n"
.text
	leaq .L7, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

3
1 should be 1
0 should be 0
36 should be 36
1 should be 1
0 should be 0
4 should be 4
256 should be 256


return code: 0


===[good5.bminor Input]===
// test func call

arr: array [4] integer = {1,2,3,4};

func: function boolean(x: integer) = {
    print x;
    return x == 2;
}
main:function integer () =
{
    print func(arr[0]), "\n", func(arr[1]), "\n", func(2), "\n";
    return 0;	
}

===[good5.bminor Output]===
.file "htrinh-compiler/tests/codegen/good5.bminor"
.data
.global arr
arr:
	.quad 1
	.quad 2
	.quad 3
	.quad 4
.text
.global func
func:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $2, %r10
	cmpq %r10, %rbx
	je .L0
# if false
.L1:
	movq $0, %r10
	jmp .L2
# if true
.L0:
	movq $1, %r10
	jmp .L2
# continue
.L2:
# end of cmp 
	movq %r10, %rax
	jmp .func_epilogue
# end of return stmt
# start of function epilogue
.func_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# code of index array
# expr int
	movq $0, %r10
	leaq arr, %rbx
	movq %r10, %rax
	movq $8, %r11
	imulq %r11
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
# load args into arg registers
	movq %rbx, %rdi
# call function
	call func
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L3:
	.string "\n"
.text
	leaq .L3, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# code of index array
# expr int
	movq $1, %r11
	leaq arr, %rbx
	movq %r11, %rax
	movq $8, %r12
	imulq %r12
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
# load args into arg registers
	movq %rbx, %rdi
# call function
	call func
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L4:
	.string "\n"
.text
	leaq .L4, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr int
	movq $2, %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call func
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L5:
	.string "\n"
.text
	leaq .L5, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

1false
2true
2true


return code: 0


===[good6.bminor Input]===
// test print characters

i: boolean = true;
a: char = 'h';
b: char;

f_char: function char (x: char) = {
    print x, "\n";
    return x;
}

f_bool: function boolean (s: boolean) = {
    print s, "\n";
    return s;
}

main:function integer () =
{
    b = a;
    c: char = 'b';
    z: boolean = false;

    print "testing function calls with global, literal, local, and reassigned strings: \n";
    print f_char(a), f_char(b), f_char(c), f_bool(i);
    print f_bool(true), f_bool(false), f_bool(z), "\n";
    
    charrr:char = '\t';
    print charrr;

    return 0;	
}
===[good6.bminor Output]===
.file "htrinh-compiler/tests/codegen/good6.bminor"
.data
.global i
i:
	.quad 0
.data
.global a
a:
.quad 104
.data
.global b
b:
.quad 0
.text
.global f_char
f_char:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "\n"
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rax
	jmp .f_char_epilogue
# end of return stmt
# start of function epilogue
.f_char_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global f_bool
f_bool:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string "\n"
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rax
	jmp .f_bool_epilogue
# end of return stmt
# start of function epilogue
.f_bool_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $24, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code of id =
# expr id
	movq a, %rbx
	leaq b, %r10
	movq %rbx, (%r10)
# end of id =
# code for value of decl c
# expr char
	movq $98, %rbx
# code for decl c
	movq %rbx, -8(%rbp)
# code for value of decl z
# expr bool
	movq $1, %rbx
# code for decl z
	movq %rbx, -16(%rbp)
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string "testing function calls with global, literal, local, and reassigned strings: \n"
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr id
	movq a, %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f_char
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr id
	movq b, %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f_char
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr id
	movq -8(%rbp), %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f_char
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr id
	movq i, %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f_bool
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr bool
	movq $0, %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f_bool
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr bool
	movq $1, %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f_bool
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr id
	movq -16(%rbp), %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f_bool
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L3:
	.string "\n"
.text
	leaq .L3, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code for value of decl charrr
# expr char
	movq $116, %rbx
# code for decl charrr
	movq %rbx, -24(%rbp)
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -24(%rbp), %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

testing function calls with global, literal, local, and reassigned strings: 
h
hh
hb
bfalse
falsefalse
falsetrue
truetrue
true
t

return code: 0


===[good7.bminor Input]===
// test comparing integers

x: integer = 5;
y: integer = 4;
z: integer = 5;

main:function integer () = {
	print "x > y should be true: ", x>y, "\n";
	print "x >= y should be true: ", x>=y, "\n";
	print "x < y should be false: ", x<y, "\n";
	print "x <= y should be false: ", x<=y, "\n";
	print "x == y should be false: ", x==y, "\n";
	print "x != y should be true: ", x!=y, "\n";
}
===[good7.bminor Output]===
.file "htrinh-compiler/tests/codegen/good7.bminor"
.data
.global x
x:
.quad 5
.data
.global y
y:
.quad 4
.data
.global z
z:
.quad 5
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "x > y should be true: "
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r10
	cmpq %r10, %rbx
	jg .L1
# if false
.L2:
	movq $0, %r10
	jmp .L3
# if true
.L1:
	movq $1, %r10
	jmp .L3
# continue
.L3:
# end of cmp 
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r11
	cmpq %r11, %rbx
	jg .L4
# if false
.L5:
	movq $0, %r11
	jmp .L6
# if true
.L4:
	movq $1, %r11
	jmp .L6
# continue
.L6:
# end of cmp 
	movq %r11, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L7:
	.string "\n"
.text
	leaq .L7, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L8:
	.string "x >= y should be true: "
.text
	leaq .L8, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r11
	cmpq %r11, %rbx
	jge .L9
# if false
.L10:
	movq $0, %r11
	jmp .L11
# if true
.L9:
	movq $1, %r11
	jmp .L11
# continue
.L11:
# end of cmp 
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r12
	cmpq %r12, %rbx
	jge .L12
# if false
.L13:
	movq $0, %r12
	jmp .L14
# if true
.L12:
	movq $1, %r12
	jmp .L14
# continue
.L14:
# end of cmp 
	movq %r12, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L15:
	.string "\n"
.text
	leaq .L15, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L16:
	.string "x < y should be false: "
.text
	leaq .L16, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r12
	cmpq %r12, %rbx
	jl .L17
# if false
.L18:
	movq $0, %r12
	jmp .L19
# if true
.L17:
	movq $1, %r12
	jmp .L19
# continue
.L19:
# end of cmp 
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r13
	cmpq %r13, %rbx
	jl .L20
# if false
.L21:
	movq $0, %r13
	jmp .L22
# if true
.L20:
	movq $1, %r13
	jmp .L22
# continue
.L22:
# end of cmp 
	movq %r13, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L23:
	.string "\n"
.text
	leaq .L23, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L24:
	.string "x <= y should be false: "
.text
	leaq .L24, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r13
	cmpq %r13, %rbx
	jle .L25
# if false
.L26:
	movq $0, %r13
	jmp .L27
# if true
.L25:
	movq $1, %r13
	jmp .L27
# continue
.L27:
# end of cmp 
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r14
	cmpq %r14, %rbx
	jle .L28
# if false
.L29:
	movq $0, %r14
	jmp .L30
# if true
.L28:
	movq $1, %r14
	jmp .L30
# continue
.L30:
# end of cmp 
	movq %r14, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L31:
	.string "\n"
.text
	leaq .L31, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L32:
	.string "x == y should be false: "
.text
	leaq .L32, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r14
	cmpq %r14, %rbx
	je .L33
# if false
.L34:
	movq $0, %r14
	jmp .L35
# if true
.L33:
	movq $1, %r14
	jmp .L35
# continue
.L35:
# end of cmp 
	movq %r14, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L36:
	.string "\n"
.text
	leaq .L36, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L37:
	.string "x != y should be true: "
.text
	leaq .L37, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq x, %rbx
# expr id
	movq y, %r14
	cmpq %r14, %rbx
	jne .L38
# if false
.L39:
	movq $0, %r14
	jmp .L40
# if true
.L38:
	movq $1, %r14
	jmp .L40
# continue
.L40:
# end of cmp 
	movq %r14, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L41:
	.string "\n"
.text
	leaq .L41, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

x > y should be true: true
x >= y should be true: true
x < y should be false: false
x <= y should be false: false
x == y should be false: false
x != y should be true: true


return code: 1


===[good8.bminor Input]===
// test comparing bools

t: boolean = true;
f: boolean = false;

main:function integer () = {
	print "true == false should be false: ", t==f, "\n";
    print "true == true should be true: ", t==t, "\n";
    print "false == false should be true: ", f==f, "\n";
    print "true != false should be true: ", t!=f, "\n";
    print "true != true should be false: ", t!=t, "\n";
    print "false != false should be false: ", f!=f, "\n";
}
===[good8.bminor Output]===
.file "htrinh-compiler/tests/codegen/good8.bminor"
.data
.global t
t:
	.quad 0
.data
.global f
f:
	.quad 1
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "true == false should be false: "
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq t, %rbx
# expr id
	movq f, %r10
	cmpq %r10, %rbx
	je .L1
# if false
.L2:
	movq $0, %r10
	jmp .L3
# if true
.L1:
	movq $1, %r10
	jmp .L3
# continue
.L3:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L4:
	.string "\n"
.text
	leaq .L4, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L5:
	.string "true == true should be true: "
.text
	leaq .L5, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq t, %rbx
# expr id
	movq t, %r10
	cmpq %r10, %rbx
	je .L6
# if false
.L7:
	movq $0, %r10
	jmp .L8
# if true
.L6:
	movq $1, %r10
	jmp .L8
# continue
.L8:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L9:
	.string "\n"
.text
	leaq .L9, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L10:
	.string "false == false should be true: "
.text
	leaq .L10, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq f, %rbx
# expr id
	movq f, %r10
	cmpq %r10, %rbx
	je .L11
# if false
.L12:
	movq $0, %r10
	jmp .L13
# if true
.L11:
	movq $1, %r10
	jmp .L13
# continue
.L13:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L14:
	.string "\n"
.text
	leaq .L14, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L15:
	.string "true != false should be true: "
.text
	leaq .L15, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq t, %rbx
# expr id
	movq f, %r10
	cmpq %r10, %rbx
	jne .L16
# if false
.L17:
	movq $0, %r10
	jmp .L18
# if true
.L16:
	movq $1, %r10
	jmp .L18
# continue
.L18:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L19:
	.string "\n"
.text
	leaq .L19, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L20:
	.string "true != true should be false: "
.text
	leaq .L20, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq t, %rbx
# expr id
	movq t, %r10
	cmpq %r10, %rbx
	jne .L21
# if false
.L22:
	movq $0, %r10
	jmp .L23
# if true
.L21:
	movq $1, %r10
	jmp .L23
# continue
.L23:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L24:
	.string "\n"
.text
	leaq .L24, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L25:
	.string "false != false should be false: "
.text
	leaq .L25, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq f, %rbx
# expr id
	movq f, %r10
	cmpq %r10, %rbx
	jne .L26
# if false
.L27:
	movq $0, %r10
	jmp .L28
# if true
.L26:
	movq $1, %r10
	jmp .L28
# continue
.L28:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L29:
	.string "\n"
.text
	leaq .L29, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

true == false should be false: false
true == true should be true: true
false == false should be true: true
true != false should be true: true
true != true should be false: false
false != false should be false: false


return code: 1


===[good9.bminor Input]===
// test comparing char

a: char = 'a';
b: char = 'b';
c: char = 'a';

main:function integer () = {

    print "a == b should be false: ", a==b, "\n";
    print "a != b should be true: ", a!=b, "\n";
    print "a == c should be true: ", a==c, "\n";
    print "a != c should be false: ", a!=c, "\n";

}

===[good9.bminor Output]===
.file "htrinh-compiler/tests/codegen/good9.bminor"
.data
.global a
a:
.quad 97
.data
.global b
b:
.quad 98
.data
.global c
c:
.quad 97
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "a == b should be false: "
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq a, %rbx
# expr id
	movq b, %r10
	cmpq %r10, %rbx
	je .L1
# if false
.L2:
	movq $0, %r10
	jmp .L3
# if true
.L1:
	movq $1, %r10
	jmp .L3
# continue
.L3:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L4:
	.string "\n"
.text
	leaq .L4, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L5:
	.string "a != b should be true: "
.text
	leaq .L5, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq a, %rbx
# expr id
	movq b, %r10
	cmpq %r10, %rbx
	jne .L6
# if false
.L7:
	movq $0, %r10
	jmp .L8
# if true
.L6:
	movq $1, %r10
	jmp .L8
# continue
.L8:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L9:
	.string "\n"
.text
	leaq .L9, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L10:
	.string "a == c should be true: "
.text
	leaq .L10, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq a, %rbx
# expr id
	movq c, %r10
	cmpq %r10, %rbx
	je .L11
# if false
.L12:
	movq $0, %r10
	jmp .L13
# if true
.L11:
	movq $1, %r10
	jmp .L13
# continue
.L13:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L14:
	.string "\n"
.text
	leaq .L14, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L15:
	.string "a != c should be false: "
.text
	leaq .L15, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of cmp 
# expr id
	movq a, %rbx
# expr id
	movq c, %r10
	cmpq %r10, %rbx
	jne .L16
# if false
.L17:
	movq $0, %r10
	jmp .L18
# if true
.L16:
	movq $1, %r10
	jmp .L18
# continue
.L18:
# end of cmp 
	movq %r10, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L19:
	.string "\n"
.text
	leaq .L19, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

a == b should be false: false
a != b should be true: true
a == c should be true: true
a != c should be false: false


return code: 1


====Bad Tests====
=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
strlen: function integer(s: string);
f: function integer(i: integer);

main: function integer () = {
	if (f(strlen("hi")) > strlen("there")) {print "no\n";}
	if (f(f(strlen("hi"))) > strlen("there")) print "ok\n";

	return 0;
}

f: function integer(i: integer) = {
	return i*2;
}

===[good1.bminor Output]===
.file "../hidden-tests/codegen/good1.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# start of if stmt
# condition expr
# code of cmp 
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr string
.data
.L2:
	.string "hi"
.text
	leaq .L2, %rbx
# end of expr string
# load args into arg registers
	movq %rbx, %rdi
# call function
	call strlen
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr string
.data
.L3:
	.string "there"
.text
	leaq .L3, %r10
# end of expr string
# load args into arg registers
	movq %r10, %rdi
# call function
	call strlen
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %r10
# end of func call
	cmpq %r10, %rbx
	jg .L4
# if false
.L5:
	movq $0, %r10
	jmp .L6
# if true
.L4:
	movq $1, %r10
	jmp .L6
# continue
.L6:
# end of cmp 
# code of cmp 
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr string
.data
.L7:
	.string "hi"
.text
	leaq .L7, %rbx
# end of expr string
# load args into arg registers
	movq %rbx, %rdi
# call function
	call strlen
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr string
.data
.L8:
	.string "there"
.text
	leaq .L8, %r11
# end of expr string
# load args into arg registers
	movq %r11, %rdi
# call function
	call strlen
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %r11
# end of func call
	cmpq %r11, %rbx
	jg .L9
# if false
.L10:
	movq $0, %r11
	jmp .L11
# if true
.L9:
	movq $1, %r11
	jmp .L11
# continue
.L11:
# end of cmp 
	cmpq $0, %r11
	je .L0
# if body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L12:
	.string "no\n"
.text
	leaq .L12, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
	jmp .L1
# false label
.L0:
# else body
.L1:
# end of if stmt
# start of if stmt
# condition expr
# code of cmp 
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr string
.data
.L15:
	.string "hi"
.text
	leaq .L15, %rbx
# end of expr string
# load args into arg registers
	movq %rbx, %rdi
# call function
	call strlen
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr string
.data
.L16:
	.string "there"
.text
	leaq .L16, %r11
# end of expr string
# load args into arg registers
	movq %r11, %rdi
# call function
	call strlen
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %r11
# end of func call
	cmpq %r11, %rbx
	jg .L17
# if false
.L18:
	movq $0, %r11
	jmp .L19
# if true
.L17:
	movq $1, %r11
	jmp .L19
# continue
.L19:
# end of cmp 
# code of cmp 
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr string
.data
.L20:
	.string "hi"
.text
	leaq .L20, %rbx
# end of expr string
# load args into arg registers
	movq %rbx, %rdi
# call function
	call strlen
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr string
.data
.L21:
	.string "there"
.text
	leaq .L21, %r12
# end of expr string
# load args into arg registers
	movq %r12, %rdi
# call function
	call strlen
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %r12
# end of func call
	cmpq %r12, %rbx
	jg .L22
# if false
.L23:
	movq $0, %r12
	jmp .L24
# if true
.L22:
	movq $1, %r12
	jmp .L24
# continue
.L24:
# end of cmp 
	cmpq $0, %r12
	je .L13
# if body
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L25:
	.string "ok\n"
.text
	leaq .L25, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
	jmp .L14
# false label
.L13:
# else body
.L14:
# end of if stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global f
f:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# code of mult
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $2, %r12
	movq %r12, %rax
	imulq %rbx
	movq %rax, %r12
# end of mult
	movq %r12, %rax
	jmp .f_epilogue
# end of return stmt
# start of function epilogue
.f_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

ok


return code: 0


===[good11.bminor Input]===
main: function integer () = {
	x: integer = 20;
	y: integer = x;
	{
		x: integer = 10;
		y = y + x;
	}

	{
		{
			y = y + x;
			x: integer = 2;
			y = y + x;
		}
		y = y + x;
		x: integer = 3;
		y = y + x;
	}
	return y + x;
}

===[good11.bminor Output]===
.file "../hidden-tests/codegen/good11.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $40, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl x
# expr int
	movq $20, %rbx
# code for decl x
	movq %rbx, -8(%rbp)
# code for value of decl y
# expr id
	movq -8(%rbp), %rbx
# code for decl y
	movq %rbx, -16(%rbp)
# code for value of decl x
# expr int
	movq $10, %rbx
# code for decl x
	movq %rbx, -24(%rbp)
# code of id =
# code of add
# expr id
	movq -16(%rbp), %rbx
# expr id
	movq -24(%rbp), %r10
	addq %rbx, %r10
# end of add
	leaq -16(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# code of id =
# code of add
# expr id
	movq -16(%rbp), %rbx
# expr id
	movq -8(%rbp), %r10
	addq %rbx, %r10
# end of add
	leaq -16(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# code for value of decl x
# expr int
	movq $2, %rbx
# code for decl x
	movq %rbx, -32(%rbp)
# code of id =
# code of add
# expr id
	movq -16(%rbp), %rbx
# expr id
	movq -32(%rbp), %r10
	addq %rbx, %r10
# end of add
	leaq -16(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# code of id =
# code of add
# expr id
	movq -16(%rbp), %rbx
# expr id
	movq -8(%rbp), %r10
	addq %rbx, %r10
# end of add
	leaq -16(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# code for value of decl x
# expr int
	movq $3, %rbx
# code for decl x
	movq %rbx, -40(%rbp)
# code of id =
# code of add
# expr id
	movq -16(%rbp), %rbx
# expr id
	movq -40(%rbp), %r10
	addq %rbx, %r10
# end of add
	leaq -16(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# return stmt
# code of add
# expr id
	movq -16(%rbp), %rbx
# expr id
	movq -8(%rbp), %r10
	addq %rbx, %r10
# end of add
	movq %r10, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue



return code: 95


===[good8.bminor Input]===
abs: function integer(n: integer);

digits: array [6] integer = {
	14,
	8,
	6168,
	42,
	0,
	74546
};

main:function integer () = {
	digits[4] = -468;
	i: integer = 0;
	for (; abs(digits[i]) == digits[i];) {
		print digits[i];
		i = i + 1;
		print ' ';
	}
	print '\n';

	return 0;
}

===[good8.bminor Output]===
.file "../hidden-tests/codegen/good8.bminor"
.data
.global digits
digits:
	.quad 14
	.quad 8
	.quad 6168
	.quad 42
	.quad 0
	.quad 74546
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code of array =
# expr int
	movq $4, %rbx
# code of negate
# expr int
	movq $468, %r11
	negq %r11
# end of negate
	leaq digits, %r10
	movq %rbx, %rax
	movq $8, %r12
	imulq %r12
	addq %r10, %rax
	movq %r11, (%rax)
# end of array =
# code for value of decl i
# expr int
	movq $0, %rbx
# code for decl i
	movq %rbx, -8(%rbp)
# start of for loop
# init expr
.L0:
# condition expr
# code of cmp 
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# code of index array
# expr id
	movq -8(%rbp), %r10
	leaq digits, %rbx
	movq %r10, %rax
	movq $8, %r11
	imulq %r11
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
# load args into arg registers
	movq %rbx, %rdi
# call function
	call abs
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# code of index array
# expr id
	movq -8(%rbp), %r12
	leaq digits, %r11
	movq %r12, %rax
	movq $8, %r13
	imulq %r13
	addq %r11, %rax
	movq (%rax), %r11
# end of index array
	cmpq %r11, %rbx
	je .L2
# if false
.L3:
	movq $0, %r11
	jmp .L4
# if true
.L2:
	movq $1, %r11
	jmp .L4
# continue
.L4:
# end of cmp 
	cmpq $0, %r11
	je .L1
# loop body
# print stmt
	pushq %r10
	pushq %r11
# code of index array
# expr id
	movq -8(%rbp), %r11
	leaq digits, %rbx
	movq %r11, %rax
	movq $8, %r13
	imulq %r13
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# code of add
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $1, %r13
	addq %rbx, %r13
# end of add
	leaq -8(%rbp), %rbx
	movq %r13, (%rbx)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# expr char
	movq $32, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
# next expr
	jmp .L0
.L1:
# end of for loop
# print stmt
	pushq %r10
	pushq %r11
# expr char
	movq $110, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

14 8 6168 42 n

return code: 0


===[good13.bminor Input]===
foo_epilogue: function integer () = {
	return 2;
}

foo: function integer ();

main: function integer () = {
	return foo() * 11;
}

main_epilogue: function integer () = {
	return foo_epilogue() + 3;
}

foo: function integer () = {
	return main_epilogue() - 1;
}

===[good13.bminor Output]===
.file "../hidden-tests/codegen/good13.bminor"
.text
.global foo_epilogue
foo_epilogue:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# expr int
	movq $2, %rbx
	movq %rbx, %rax
	jmp .foo_epilogue_epilogue
# end of return stmt
# start of function epilogue
.foo_epilogue_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# code of mult
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# load args into arg registers
# call function
	call foo
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# expr int
	movq $11, %r10
	movq %r10, %rax
	imulq %rbx
	movq %rax, %r10
# end of mult
	movq %r10, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main_epilogue
main_epilogue:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# code of add
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# load args into arg registers
# call function
	call foo_epilogue
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# expr int
	movq $3, %r10
	addq %rbx, %r10
# end of add
	movq %r10, %rax
	jmp .main_epilogue_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global foo
foo:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# code of sub
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# load args into arg registers
# call function
	call main_epilogue
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# expr int
	movq $1, %r10
	subq %rbx, %r10
# end of sub
	movq %r10, %rax
	jmp .foo_epilogue
# end of return stmt
# start of function epilogue
.foo_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue



return code: 212


===[good12.bminor Input]===
main: function integer () = {
	return 4 + 9 / (-2 - (-5)) + (((2 + 1) * 4) - 1) % 3 * 7 - 8;
}

===[good12.bminor Output]===
.file "../hidden-tests/codegen/good12.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# code of sub
# code of add
# code of add
# expr int
	movq $4, %rbx
# code of div
# expr int
	movq $9, %r10
# code of sub
# code of negate
# expr int
	movq $2, %r11
	negq %r11
# end of negate
# code of negate
# expr int
	movq $5, %r12
	negq %r12
# end of negate
	subq %r11, %r12
# end of sub
	movq %r10, %rax
	xor %rdx, %rdx
	idivq %r12
	movq %rax, %r12
# end of div
	addq %rbx, %r12
# end of add
# code of mult
# code of mod
# code of sub
# code of mult
# code of add
# expr int
	movq $2, %rbx
# expr int
	movq $1, %r10
	addq %rbx, %r10
# end of add
# expr int
	movq $4, %rbx
	movq %rbx, %rax
	imulq %r10
	movq %rax, %rbx
# end of mult
# expr int
	movq $1, %r10
	subq %rbx, %r10
# end of sub
# expr int
	movq $3, %rbx
	movq %r10, %rax
	xor %rdx, %rdx
	idivq %rbx
	movq %rdx, %rbx
# end of mod
# expr int
	movq $7, %r10
	movq %r10, %rax
	imulq %rbx
	movq %rax, %r10
# end of mult
	addq %r12, %r10
# end of add
# expr int
	movq $8, %rbx
	subq %r10, %rbx
# end of sub
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue



return code: 249


===[good15.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=179

strdup: function string (s: string);

main: function integer () = {
	a: string = "sssss";
	b: string = strdup(a);
	if (a==b) return 22; else return 11;
}

===[good15.bminor Output]===
.file "../hidden-tests/codegen/good15.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $16, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl a
# expr string
.data
.L0:
	.string "sssss"
.text
	leaq .L0, %rbx
# end of expr string
# code for decl a
	movq %rbx, -8(%rbp)
# code for value of decl b
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr id
	movq -8(%rbp), %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call strdup
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# code for decl b
	movq %rbx, -16(%rbp)
# start of if stmt
# condition expr
# code of string cmp 
# expr id
	movq -8(%rbp), %rbx
# expr id
	movq -16(%rbp), %r10
	pushq %r10
	pushq %r11
	movq %rbx, %rdi
	movq %r10, %rsi
	call string_compare
	popq %r11
	popq %r10
	cmpq $1, %rax
	je .L3
# if false
.L4:
	movq $0, %r10
	jmp .L5
# if true
.L3:
	movq $1, %r10
	jmp .L5
# continue
.L5:
# end of cmp 
	cmpq $0, %r10
	je .L1
# if body
# return stmt
# expr int
	movq $22, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
	jmp .L2
# false label
.L1:
# else body
# return stmt
# expr int
	movq $11, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
.L2:
# end of if stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue



return code: 22


===[good17.bminor Input]===
a1: integer;
a2: integer = 111;
a3: boolean = false;

A: function integer() = {
	if (a3) return a1 * a2;
	a2: integer = 3;
	if (!!!a3) return a1 + a2;
	return 0;
}

main: function integer() = { return A(); }

===[good17.bminor Output]===
.file "../hidden-tests/codegen/good17.bminor"
.data
.global a1
a1:
.quad 0
.data
.global a2
a2:
.quad 111
.data
.global a3
a3:
	.quad 1
.text
.global A
A:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# start of if stmt
# condition expr
# expr id
	movq a3, %rbx
	cmpq $0, %rbx
	je .L0
# if body
# return stmt
# code of mult
# expr id
	movq a1, %r10
# expr id
	movq a2, %r11
	movq %r11, %rax
	imulq %r10
	movq %rax, %r11
# end of mult
	movq %r11, %rax
	jmp .A_epilogue
# end of return stmt
	jmp .L1
# false label
.L0:
# else body
.L1:
# end of if stmt
# code for value of decl a2
# expr int
	movq $3, %rbx
# code for decl a2
	movq %rbx, -8(%rbp)
# start of if stmt
# condition expr
# code of not
# code of not
# code of not
# expr id
	movq a3, %rbx
	cmpq $0, %rbx
	je .L8
	movq $0, %rbx
	jmp .L9
.L8:
	movq $1, %rbx
.L9:
# end of not
	cmpq $0, %rbx
	je .L6
	movq $0, %rbx
	jmp .L7
.L6:
	movq $1, %rbx
.L7:
# end of not
	cmpq $0, %rbx
	je .L4
	movq $0, %rbx
	jmp .L5
.L4:
	movq $1, %rbx
.L5:
# end of not
	cmpq $0, %rbx
	je .L2
# if body
# return stmt
# code of add
# expr id
	movq a1, %r10
# expr id
	movq -8(%rbp), %r11
	addq %r10, %r11
# end of add
	movq %r11, %rax
	jmp .A_epilogue
# end of return stmt
	jmp .L3
# false label
.L2:
# else body
.L3:
# end of if stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .A_epilogue
# end of return stmt
# start of function epilogue
.A_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# load args into arg registers
# call function
	call A
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue



return code: 0


===[good18.bminor Input]===
b1: integer = 3;
b2: integer = 6;
b3: integer = 9;

B: function integer(b3: integer, b4: integer) = {
	print b1 * b2 + b3 % b4;
	print '\n';
	b3 = 37;
	return b3;
}

main: function integer () = {
	print B(5, 3);
	return b3;
}

===[good18.bminor Output]===
.file "../hidden-tests/codegen/good18.bminor"
.data
.global b1
b1:
.quad 3
.data
.global b2
b2:
.quad 6
.data
.global b3
b3:
.quad 9
.text
.global B
B:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	pushq %rsi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# code of add
# code of mult
# expr id
	movq b1, %rbx
# expr id
	movq b2, %r10
	movq %r10, %rax
	imulq %rbx
	movq %rax, %r10
# end of mult
# code of mod
# expr id
	movq -8(%rbp), %rbx
# expr id
	movq -16(%rbp), %r11
	movq %rbx, %rax
	xor %rdx, %rdx
	idivq %r11
	movq %rdx, %r11
# end of mod
	addq %r10, %r11
# end of add
	movq %r11, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr char
	movq $110, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# expr int
	movq $37, %rbx
	leaq -8(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
# return stmt
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rax
	jmp .B_epilogue
# end of return stmt
# start of function epilogue
.B_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr int
	movq $5, %rbx
# expr int
	movq $3, %r10
# load args into arg registers
	movq %rbx, %rdi
	movq %r10, %rsi
# call function
	call B
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr id
	movq b3, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

20n37

return code: 9


===[good4.bminor Input]===
collatz: function integer(n: integer, acc: integer) = {
	print n, " ", acc, "\n";
	if (n == 1) return acc;

	if (n % 2 == 0) return collatz(n/2, acc + 1);
	else return collatz(3*n + 1, acc + 1);
}

main:function integer ()=
{
	return collatz(27, 0);
}

===[good4.bminor Output]===
.file "../hidden-tests/codegen/good4.bminor"
.text
.global collatz
collatz:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	pushq %rsi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string " "
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq -16(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string "\n"
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of if stmt
# condition expr
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $1, %r10
	cmpq %r10, %rbx
	je .L4
# if false
.L5:
	movq $0, %r10
	jmp .L6
# if true
.L4:
	movq $1, %r10
	jmp .L6
# continue
.L6:
# end of cmp 
	cmpq $0, %r10
	je .L2
# if body
# return stmt
# expr id
	movq -16(%rbp), %rbx
	movq %rbx, %rax
	jmp .collatz_epilogue
# end of return stmt
	jmp .L3
# false label
.L2:
# else body
.L3:
# end of if stmt
# start of if stmt
# condition expr
# code of cmp 
# code of mod
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $2, %r10
	movq %rbx, %rax
	xor %rdx, %rdx
	idivq %r10
	movq %rdx, %r10
# end of mod
# expr int
	movq $0, %rbx
	cmpq %rbx, %r10
	je .L9
# if false
.L10:
	movq $0, %rbx
	jmp .L11
# if true
.L9:
	movq $1, %rbx
	jmp .L11
# continue
.L11:
# end of cmp 
	cmpq $0, %rbx
	je .L7
# if body
# return stmt
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# code of div
# expr id
	movq -8(%rbp), %r10
# expr int
	movq $2, %r11
	movq %r10, %rax
	xor %rdx, %rdx
	idivq %r11
	movq %rax, %r11
# end of div
# code of add
# expr id
	movq -16(%rbp), %r10
# expr int
	movq $1, %r12
	addq %r10, %r12
# end of add
# load args into arg registers
	movq %r11, %rdi
	movq %r12, %rsi
# call function
	call collatz
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %r10
# end of func call
	movq %r10, %rax
	jmp .collatz_epilogue
# end of return stmt
	jmp .L8
# false label
.L7:
# else body
# return stmt
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# code of add
# code of mult
# expr int
	movq $3, %r10
# expr id
	movq -8(%rbp), %r11
	movq %r11, %rax
	imulq %r10
	movq %rax, %r11
# end of mult
# expr int
	movq $1, %r10
	addq %r11, %r10
# end of add
# code of add
# expr id
	movq -16(%rbp), %r11
# expr int
	movq $1, %r12
	addq %r11, %r12
# end of add
# load args into arg registers
	movq %r10, %rdi
	movq %r12, %rsi
# call function
	call collatz
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %r10
# end of func call
	movq %r10, %rax
	jmp .collatz_epilogue
# end of return stmt
.L8:
# end of if stmt
# start of function epilogue
.collatz_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr int
	movq $27, %rbx
# expr int
	movq $0, %r10
# load args into arg registers
	movq %rbx, %rdi
	movq %r10, %rsi
# call function
	call collatz
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

27 0
82 1
41 2
124 3
62 4
31 5
94 6
47 7
142 8
71 9
214 10
107 11
322 12
161 13
484 14
242 15
121 16
364 17
182 18
91 19
274 20
137 21
412 22
206 23
103 24
310 25
155 26
466 27
233 28
700 29
350 30
175 31
526 32
263 33
790 34
395 35
1186 36
593 37
1780 38
890 39
445 40
1336 41
668 42
334 43
167 44
502 45
251 46
754 47
377 48
1132 49
566 50
283 51
850 52
425 53
1276 54
638 55
319 56
958 57
479 58
1438 59
719 60
2158 61
1079 62
3238 63
1619 64
4858 65
2429 66
7288 67
3644 68
1822 69
911 70
2734 71
1367 72
4102 73
2051 74
6154 75
3077 76
9232 77
4616 78
2308 79
1154 80
577 81
1732 82
866 83
433 84
1300 85
650 86
325 87
976 88
488 89
244 90
122 91
61 92
184 93
92 94
46 95
23 96
70 97
35 98
106 99
53 100
160 101
80 102
40 103
20 104
10 105
5 106
16 107
8 108
4 109
2 110
1 111


return code: 111


===[good20.bminor Input]===
D: function integer() = {
	d1: integer = 5;
	d2: integer = d1 + 1; //6
	{
		d3: integer = 9;
		d2: integer = d3 + d1 - 3; //11
		d4: integer = -1;
		d2 = d2 + d3; //20
		print d2 - d4, "\n";
	}
	d4: integer = 16;
	print d2 - d4, '\n';
	{
		d4: integer = -2;
		d3: integer = 1000;
		print d3 + 10;
		print "\n";
		print d4;
		print '\n';
	}
	print d4;
	return 3;
}

main: function integer () = {
	return D();
}

===[good20.bminor Output]===
.file "../hidden-tests/codegen/good20.bminor"
.text
.global D
D:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $64, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl d1
# expr int
	movq $5, %rbx
# code for decl d1
	movq %rbx, -8(%rbp)
# code for value of decl d2
# code of add
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $1, %r10
	addq %rbx, %r10
# end of add
# code for decl d2
	movq %r10, -16(%rbp)
# code for value of decl d3
# expr int
	movq $9, %rbx
# code for decl d3
	movq %rbx, -24(%rbp)
# code for value of decl d2
# code of sub
# code of add
# expr id
	movq -24(%rbp), %rbx
# expr id
	movq -8(%rbp), %r10
	addq %rbx, %r10
# end of add
# expr int
	movq $3, %rbx
	subq %r10, %rbx
# end of sub
# code for decl d2
	movq %rbx, -32(%rbp)
# code for value of decl d4
# code of negate
# expr int
	movq $1, %rbx
	negq %rbx
# end of negate
# code for decl d4
	movq %rbx, -40(%rbp)
# code of id =
# code of add
# expr id
	movq -32(%rbp), %rbx
# expr id
	movq -24(%rbp), %r10
	addq %rbx, %r10
# end of add
	leaq -32(%rbp), %rbx
	movq %r10, (%rbx)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# code of sub
# expr id
	movq -32(%rbp), %rbx
# expr id
	movq -40(%rbp), %r10
	subq %rbx, %r10
# end of sub
	movq %r10, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "\n"
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code for value of decl d4
# expr int
	movq $16, %rbx
# code for decl d4
	movq %rbx, -48(%rbp)
# print stmt
	pushq %r10
	pushq %r11
# code of sub
# expr id
	movq -16(%rbp), %rbx
# expr id
	movq -48(%rbp), %r10
	subq %rbx, %r10
# end of sub
	movq %r10, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr char
	movq $110, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
# code for value of decl d4
# code of negate
# expr int
	movq $2, %rbx
	negq %rbx
# end of negate
# code for decl d4
	movq %rbx, -56(%rbp)
# code for value of decl d3
# expr int
	movq $1000, %rbx
# code for decl d3
	movq %rbx, -64(%rbp)
# print stmt
	pushq %r10
	pushq %r11
# code of add
# expr id
	movq -64(%rbp), %rbx
# expr int
	movq $10, %r10
	addq %rbx, %r10
# end of add
	movq %r10, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string "\n"
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -56(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr char
	movq $110, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -48(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $3, %rbx
	movq %rbx, %rax
	jmp .D_epilogue
# end of return stmt
# start of function epilogue
.D_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# load args into arg registers
# call function
	call D
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

1
10n1010
-2n16

return code: 3


===[good3.bminor Input]===
T: array [8] integer = {2, 1, 1, 2, 1, 2, 0, 3};

main:function integer ()=
{
	i: integer = 0;
        for (;;) {
		if (T[i] == 0) return T[5] + 10;
		else if (T[i] == 1) i++;
		else if (T[i] == 2) T[i++]--;
		else return 1;
	}

	return 0;
}

===[good3.bminor Output]===
TEST NOT PASSED - COMPILE ERROR


../hidden-tests/codegen/good3.bminor.s: Assembler messages:
../hidden-tests/codegen/good3.bminor.s:168: Error: too many memory references for `movq'
../hidden-tests/codegen/good3.bminor.s:169: Error: too many memory references for `movq'
../hidden-tests/codegen/good3.bminor.s:171: Error: too many memory references for `movq'

return code: 1


===[good5.bminor Input]===
A: function boolean(x: integer, y: integer);
B: function integer(x: char);
C: function char(a: string);

main: function integer() = {
	if (A(B('d') - 1, 10)) {
		x: integer = 3;
		return 2 * B('!') + x;
	}
	return B(C("hello")) % 3;
}

A: function boolean(x: integer, y: integer) = {
	return x == y;
}

B: function integer(c: char) = {
	if (c == '!')
		return 10;
	else {return 11;}
}

C: function char(a: string) = {
	return '!';
}

===[good5.bminor Output]===
.file "../hidden-tests/codegen/good5.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# start of if stmt
# condition expr
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# code of sub
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr char
	movq $100, %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call B
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# expr int
	movq $1, %r10
	subq %rbx, %r10
# end of sub
# expr int
	movq $10, %rbx
# load args into arg registers
	movq %r10, %rdi
	movq %rbx, %rsi
# call function
	call A
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	cmpq $0, %rbx
	je .L0
# if body
# code for value of decl x
# expr int
	movq $3, %r10
# code for decl x
	movq %r10, -8(%rbp)
# return stmt
# code of add
# code of mult
# expr int
	movq $2, %r10
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr char
	movq $33, %r11
# load args into arg registers
	movq %r11, %rdi
# call function
	call B
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %r11
# end of func call
	movq %r11, %rax
	imulq %r10
	movq %rax, %r11
# end of mult
# expr id
	movq -8(%rbp), %r10
	addq %r11, %r10
# end of add
	movq %r10, %rax
	jmp .main_epilogue
# end of return stmt
	jmp .L1
# false label
.L0:
# else body
.L1:
# end of if stmt
# return stmt
# code of mod
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr string
.data
.L2:
	.string "hello"
.text
	leaq .L2, %rbx
# end of expr string
# load args into arg registers
	movq %rbx, %rdi
# call function
	call C
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# load args into arg registers
	movq %rbx, %rdi
# call function
	call B
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
# expr int
	movq $3, %r10
	movq %rbx, %rax
	xor %rdx, %rdx
	idivq %r10
	movq %rdx, %r10
# end of mod
	movq %r10, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global A
A:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	pushq %rsi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr id
	movq -16(%rbp), %r10
	cmpq %r10, %rbx
	je .L3
# if false
.L4:
	movq $0, %r10
	jmp .L5
# if true
.L3:
	movq $1, %r10
	jmp .L5
# continue
.L5:
# end of cmp 
	movq %r10, %rax
	jmp .A_epilogue
# end of return stmt
# start of function epilogue
.A_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global B
B:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# start of if stmt
# condition expr
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr char
	movq $33, %r10
	cmpq %r10, %rbx
	je .L8
# if false
.L9:
	movq $0, %r10
	jmp .L10
# if true
.L8:
	movq $1, %r10
	jmp .L10
# continue
.L10:
# end of cmp 
	cmpq $0, %r10
	je .L6
# if body
# return stmt
# expr int
	movq $10, %rbx
	movq %rbx, %rax
	jmp .B_epilogue
# end of return stmt
	jmp .L7
# false label
.L6:
# else body
# return stmt
# expr int
	movq $11, %rbx
	movq %rbx, %rax
	jmp .B_epilogue
# end of return stmt
.L7:
# end of if stmt
# start of function epilogue
.B_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global C
C:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# return stmt
# expr char
	movq $33, %rbx
	movq %rbx, %rax
	jmp .C_epilogue
# end of return stmt
# start of function epilogue
.C_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue



return code: 1


===[good6.bminor Input]===
f: function boolean(b: boolean) = {
	return !b;
}

x: integer = -4;

main:function integer ()=
{
	y: integer = 10;
	if (f(f(f(f(f(x <= y)))))) return 1;
	else if (x < y - x*y) {
		return 4;
	} else return 2;
}

===[good6.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

resolving...
b resolves to param 1
f resolves to global f
f resolves to global f
f resolves to global f
f resolves to global f
f resolves to global f
x resolves to global x
y resolves to local 1
x resolves to global x
y resolves to local 1
x resolves to global x
y resolves to local 1

type checking...
type error: cannot declare non-literal value in global scope
			x: integer = -4;
typecheck failed.


return code: 1


===[good7.bminor Input]===
f: function void (i: integer) = {
	N: integer;
	for (N = 0; i > 0; i--) {
		print N;
		N = N + 1;
	}
}

main:function integer () = {
	N: integer = 6;
	for (;;N--) {
		f(N);
		print '\n';
		if (N == 0) return 0;
	}

	return 1;
}

===[good7.bminor Output]===
.file "../hidden-tests/codegen/good7.bminor"
.text
.global f
f:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# start of for loop
# init expr
# code of id =
# expr int
	movq $0, %rbx
	leaq -16(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
.L0:
# condition expr
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $0, %r10
	cmpq %r10, %rbx
	jg .L2
# if false
.L3:
	movq $0, %r10
	jmp .L4
# if true
.L2:
	movq $1, %r10
	jmp .L4
# continue
.L4:
# end of cmp 
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $0, %r11
	cmpq %r11, %rbx
	jg .L5
# if false
.L6:
	movq $0, %r11
	jmp .L7
# if true
.L5:
	movq $1, %r11
	jmp .L7
# continue
.L7:
# end of cmp 
	cmpq $0, %r11
	je .L1
# loop body
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -16(%rbp), %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# code of add
# expr id
	movq -16(%rbp), %rbx
# expr int
	movq $1, %r11
	addq %rbx, %r11
# end of add
	leaq -16(%rbp), %rbx
	movq %r11, (%rbx)
# end of id =
# next expr
# code of --
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %r11
	decq %rbx
	movq %rbx, -8(%rbp)
# end of --
	jmp .L0
.L1:
# end of for loop
# start of function epilogue
.f_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl N
# expr int
	movq $6, %rbx
# code for decl N
	movq %rbx, -8(%rbp)
# start of for loop
# init expr
.L8:
# condition expr
# loop body
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr id
	movq -8(%rbp), %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f
# restore regs after func call
	popq %r11
	popq %r10
# end of func call
# print stmt
	pushq %r10
	pushq %r11
# expr char
	movq $110, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
# start of if stmt
# condition expr
# code of cmp 
# expr id
	movq -8(%rbp), %rbx
# expr int
	movq $0, %r11
	cmpq %r11, %rbx
	je .L12
# if false
.L13:
	movq $0, %r11
	jmp .L14
# if true
.L12:
	movq $1, %r11
	jmp .L14
# continue
.L14:
# end of cmp 
	cmpq $0, %r11
	je .L10
# if body
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
	jmp .L11
# false label
.L10:
# else body
.L11:
# end of if stmt
# next expr
# code of --
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %r11
	decq %rbx
	movq %rbx, -8(%rbp)
# end of --
	jmp .L8
.L9:
# end of for loop
# return stmt
# expr int
	movq $1, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

012345n01234n0123n012n01n0nn

return code: 0


===[good9.bminor Input]===
a: array[4] integer;
main: function integer() = {
	a[2] = 60;
	return a[2] + a[2] / 20 * 3 - a[1];
}

===[good9.bminor Output]===
.file "../hidden-tests/codegen/good9.bminor"
.data
.global a
a:
	.quad 0
	.quad 0
	.quad 0
	.quad 0
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code of array =
# expr int
	movq $2, %rbx
# expr int
	movq $60, %r11
	leaq a, %r10
	movq %rbx, %rax
	movq $8, %r12
	imulq %r12
	addq %r10, %rax
	movq %r11, (%rax)
# end of array =
# return stmt
# code of sub
# code of add
# code of index array
# expr int
	movq $2, %r10
	leaq a, %rbx
	movq %r10, %rax
	movq $8, %r11
	imulq %r11
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
# code of mult
# code of div
# code of index array
# expr int
	movq $2, %r12
	leaq a, %r11
	movq %r12, %rax
	movq $8, %r13
	imulq %r13
	addq %r11, %rax
	movq (%rax), %r11
# end of index array
# expr int
	movq $20, %r13
	movq %r11, %rax
	xor %rdx, %rdx
	idivq %r13
	movq %rax, %r13
# end of div
# expr int
	movq $3, %r11
	movq %r11, %rax
	imulq %r13
	movq %rax, %r11
# end of mult
	addq %rbx, %r11
# end of add
# code of index array
# expr int
	movq $1, %r13
	leaq a, %rbx
	movq %r13, %rax
	movq $8, %r14
	imulq %r14
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	subq %r11, %rbx
# end of sub
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue



return code: 187


===[good2.bminor Input]===


X: array [4] integer = {11, 30, 22, 0};

main: function integer () = {
	i: integer;
	for (i = 0; X[i] != 0; i++)
		print X[i], ' ', X[i] % 3, '\n';

	return 0;
}

===[good2.bminor Output]===
.file "../hidden-tests/codegen/good2.bminor"
.data
.global X
X:
	.quad 11
	.quad 30
	.quad 22
	.quad 0
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# start of for loop
# init expr
# code of id =
# expr int
	movq $0, %rbx
	leaq -8(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
.L0:
# condition expr
# code of cmp 
# code of index array
# expr id
	movq -8(%rbp), %r10
	leaq X, %rbx
	movq %r10, %rax
	movq $8, %r11
	imulq %r11
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
# expr int
	movq $0, %r11
	cmpq %r11, %rbx
	jne .L2
# if false
.L3:
	movq $0, %r11
	jmp .L4
# if true
.L2:
	movq $1, %r11
	jmp .L4
# continue
.L4:
# end of cmp 
	cmpq $0, %r11
	je .L1
# loop body
# print stmt
	pushq %r10
	pushq %r11
# code of index array
# expr id
	movq -8(%rbp), %r11
	leaq X, %rbx
	movq %r11, %rax
	movq $8, %r12
	imulq %r12
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr char
	movq $32, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# code of mod
# code of index array
# expr id
	movq -8(%rbp), %r12
	leaq X, %rbx
	movq %r12, %rax
	movq $8, %r13
	imulq %r13
	addq %rbx, %rax
	movq (%rax), %rbx
# end of index array
# expr int
	movq $3, %r13
	movq %rbx, %rax
	xor %rdx, %rdx
	idivq %r13
	movq %rdx, %r13
# end of mod
	movq %r13, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr char
	movq $110, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# end of print stmt
# next expr
# code of ++
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %r13
	incq %rbx
	movq %rbx, -8(%rbp)
# end of ++
	jmp .L0
.L1:
# end of for loop
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

11 2n30 0n22 1n

return code: 0


===[good19.bminor Input]===
c1: integer = -1;
c3: integer = 100;

d1: integer = 1;
d2: integer = 2;

C: function integer(c1: integer, c2: integer) = {
	c3: integer = 11;
	c4: integer = 12;
	c5: integer = 13;
	return c1 + c2 + c3 + c4;
}

D: function integer(d1: integer, d2: integer) = {
	d3: integer = -3;
	d4: integer = 4;
	d5: integer = 5;
	return d1 + d2 + d3 - d4;
}

main: function integer() = {
	f: integer = D(6, 7);
	return C(1, 2);
}

===[good19.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

resolving...
c1 resolves to param 1
c2 resolves to param 2
c3 resolves to local 3
c4 resolves to local 4
d1 resolves to param 1
d2 resolves to param 2
d3 resolves to local 3
d4 resolves to local 4
D resolves to global D
C resolves to global C

type checking...
type error: cannot declare non-literal value in global scope
			c1: integer = -1;
typecheck failed.


return code: 1


===[good10.bminor Input]===
w: string = "no";

f: function void (s: string) = {
	{
		w: string = "ok";
		print w, "\n";
		w = "bad!\n";
	}
	print s, ' ', w;
	print " ";
	s = "changed\n";
	print s;
}

main:function integer ()= {
	s: string = "good";
	f(s);
	print s;

	return 0;
}

===[good10.bminor Output]===
.file "../hidden-tests/codegen/good10.bminor"
.data
.global w
w:
.quad .L0
.data
.global .L0
.L0:
.string "no"
.text
.global f
f:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl w
# expr string
.data
.L1:
	.string "ok"
.text
	leaq .L1, %rbx
# end of expr string
# code for decl w
	movq %rbx, -16(%rbp)
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -16(%rbp), %rbx
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L2:
	.string "\n"
.text
	leaq .L2, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# expr string
.data
.L3:
	.string "bad!\n"
.text
	leaq .L3, %rbx
# end of expr string
	leaq -16(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr char
	movq $32, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr id
	movq w, %rbx
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L4:
	.string " "
.text
	leaq .L4, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# code of id =
# expr string
.data
.L5:
	.string "changed\n"
.text
	leaq .L5, %rbx
# end of expr string
	leaq -8(%rbp), %r10
	movq %rbx, (%r10)
# end of id =
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# start of function epilogue
.f_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl s
# expr string
.data
.L6:
	.string "good"
.text
	leaq .L6, %rbx
# end of expr string
# code for decl s
	movq %rbx, -8(%rbp)
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# expr id
	movq -8(%rbp), %rbx
# load args into arg registers
	movq %rbx, %rdi
# call function
	call f
# restore regs after func call
	popq %r11
	popq %r10
# end of func call
# print stmt
	pushq %r10
	pushq %r11
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

ok
good no changed
good

return code: 0


===[good14.bminor Input]===
/*
Return pointer to (constant) global
string which is valid to display.
*/

s: string = "ok\n";

f: function string() = {
	t: string = s;
	return t;
}

main: function integer () = {
	print f();
	return 0;
}

===[good14.bminor Output]===
.file "../hidden-tests/codegen/good14.bminor"
.data
.global s
s:
.quad .L0
.data
.global .L0
.L0:
.string "ok\n"
.text
.global f
f:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# code for value of decl t
# expr id
	movq s, %rbx
# code for decl t
	movq %rbx, -8(%rbp)
# return stmt
# expr id
	movq -8(%rbp), %rbx
	movq %rbx, %rax
	jmp .f_epilogue
# end of return stmt
# start of function epilogue
.f_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# start of func call
# save regs for func call
	pushq %r10
	pushq %r11
# save args
# load args into arg registers
# call function
	call f
# restore regs after func call
	popq %r11
	popq %r10
# load return into scratch reg
	movq %rax, %rbx
# end of func call
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

ok


return code: 0


===[good16.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=176

main: function integer() = {
	print "Testing printing literals", '\n', 123, "abc", true, false, 5;
	return 0;
}


===[good16.bminor Output]===
.file "../hidden-tests/codegen/good16.bminor"
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# print stmt
	pushq %r10
	pushq %r11
# expr string
.data
.L0:
	.string "Testing printing literals"
.text
	leaq .L0, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr char
	movq $110, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr int
	movq $123, %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr string
.data
.L1:
	.string "abc"
.text
	leaq .L1, %rbx
# end of expr string
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr bool
	movq $0, %rbx
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr bool
	movq $1, %rbx
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# expr int
	movq $5, %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# end of print stmt
# return stmt
# expr int
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# end of return stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Testing printing literalsn123abcfalsetrue5

return code: 0


====Bad Tests====
===== SUMMARIZED CODEGEN RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 20,
      "incorrect": 0
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 17,
      "incorrect": 3
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  }
}

Codegen Project Grade
-------------------

General Structure: 23/25
---------------------------------
Overall structure is correct. Issues with typechecking
negative numbers in global scope

Codegen - Functionality 15/15 
--------------------------------------------
Assembled code runs without errors

Codegen - Assembly Structure 9/10 
--------------------------------------------
One assembly syntax error

Student Tests: 20/20
---------------------------
Passes all your tests.

Hidden Tests: 17/20
---------------------------
Passes 17 hidden tests

Code Style: 10/10
------------------------
Looks good. Great job!

Extra Credit: 0/10
------------------------

Total: 97/100
------------------------------------------
